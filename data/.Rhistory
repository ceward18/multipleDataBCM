alarmBase = alarmBase,
smoothWindow = smoothWindow)
dim(allModels)
allModels <- allModels[order(allModels$alarmBase,
allModels$smoothWindow,
allModels$peak),]
rownames(allModels) <- NULL
allModels
?swith
switch
?switch
head(dat)
?samplers
setwd("C:/Users/caitl/Documents/Postdoc/multipleDataBCM")
idx <-1
### load libraries
library(parallel)
library(nimble)
### source scripts (for movingAverage function)
source('./scripts/modelCodes.R')
### read data
dat <- read.csv('./data/nycClean.csv')
dat$smoothedCases <- round(dat$dailyCases)
dat$cumulativeCases <- cumsum(dat$smoothedCases)
peak <- c('1', '2', '3', '4', '5')
alarmBase <- c('inc', 'hosp', 'death')
smoothWindow <- 60
# 15
allModels <- expand.grid(peak = peak,
alarmBase = alarmBase,
smoothWindow = smoothWindow)
allModels <- allModels[order(allModels$alarmBase,
allModels$smoothWindow,
allModels$peak),]
rownames(allModels) <- NULL
# list of batches
tmp <- allModels[seq(1, nrow(allModels), 4),]
rownames(tmp) <- NULL
# constants for all models
N <- dat$Population[1]
# used to initialize I0 and R0
lengthI <- 3
i <- 1
peak_i <- allModels$peak[i]
alarmBase_i <- allModels$alarmBase[i]
smoothWindow_i <- allModels$smoothWindow[i]
print(paste('Running alarm:', alarmFit_i, ', peak:', peak_i))
print(paste('Running alarm basis:', alarmBase_i, ', peak:', peak_i))
# what will inform alarm function?
# (shifted so alarm is informed only by data up to time t-1)
dat$alarmBase <- switch(alarmBase_i,
'inc' = head(movingAverage(c(0, dat$dailyCases),
smoothWindow_i), -1),
'hosp' = head(movingAverage(c(0, dat$dailyHosp),
smoothWindow_i), -1),
'death' = head(movingAverage(c(0, dat$dailyDeaths),
smoothWindow_i), -1))
alarmBase_i
# what will inform alarm function?
# (shifted so alarm is informed only by data up to time t-1)
dat$alarmBase <- switch(as.character(alarmBase_i),
'inc' = head(movingAverage(c(0, dat$dailyCases),
smoothWindow_i), -1),
'hosp' = head(movingAverage(c(0, dat$dailyHosp),
smoothWindow_i), -1),
'death' = head(movingAverage(c(0, dat$dailyDeaths),
smoothWindow_i), -1))
head(dat)
alarmBase_i
head(head(movingAverage(c(0, dat$dailyCases),
smoothWindow_i), -1))
# get data for the specified peak
incData <- dat$smoothedCases[which(dat$peak == peak_i)]
alarmBase <- dat$alarmBase[which(dat$peak == peak_i)]
# initialize current number of infectious and removed individuals
if (peak_i == 1) {
# peak 1 shift 5 days for start
idxStart <- 5
incData <- incData[-c(1:idxStart)]
alarmBase <- alarmBase[-c(1:idxStart)]
} else {
idxStart <- min(which(dat$peak == peak_i))
incData <- incData[-1]
alarmBase <- alarmBase[-1]
}
# currently infectious
I0 <- sum(dat$smoothedCases[max(1, (idxStart - lengthI + 1)):(idxStart)])
R0 <- dat$cumulativeCases[idxStart] - I0
# used for posterior predictive fit
# previously observed incidence for correct smoothing at beginning of prediction
Istar0 <- dat$smoothedCases[max(1, (idxStart - smoothWindow_i + 1)):(idxStart)]
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
# debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = x)
seed <- 1
debugonce(fitAlarmModel)
# debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase_i,
N = N, I0 = I0, R0 = R0, seed = 1)
debugonce(getModelInput)
# model-specific constants, data, and inits
modelInputs <- getModelInput(incData, alarmBase, N, I0, R0)
alarmBase
alarmBase
library(nimble)
# source relevant scripts
source('./scripts/model_fit_uni.R')
debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase,
N = N, I0 = I0, R0 = R0, seed = 1)
myModel$initializeInfo()
myModel$Istar
myModel$I
source('./scripts/get_model_inputs_uni.R')
# model-specific constants, data, and inits
modelInputs <- getModelInput(incData, alarmBase, N, I0, R0)
### create nimble model
myModel <- nimbleModel(SIR_gp_uni,
data = modelInputs$dataList,
constants = modelInputs$constantsList,
inits = modelInputs$initsList)
myModel$I
myConfig <- configureMCMC(myModel)
myConfig
samples <- runMCMC(compiled$myMCMC,
niter = niter,
nburnin = nburn,
thin = nthin,
setSeed  = seed)
setwd("C:/Users/caitl/Documents/Postdoc/multipleDataBCM/./scripts")
setwd("C:/Users/caitl/Documents/Postdoc/multipleDataBCM")
i <- 9
### load libraries
library(parallel)
library(nimble)
### source scripts (for movingAverage function)
source('./scripts/modelCodes.R')
### read data
dat <- read.csv('./data/nycClean.csv')
dat$smoothedCases <- round(dat$dailyCases)
dat$cumulativeCases <- cumsum(dat$smoothedCases)
peak <- c('1', '2', '3', '4', '5')
alarmBase <- c('inc', 'hosp', 'death')
smoothWindow <- 60
# 15
allModels <- expand.grid(peak = peak,
alarmBase = alarmBase,
smoothWindow = smoothWindow)
allModels <- allModels[order(allModels$alarmBase,
allModels$smoothWindow,
allModels$peak),]
rownames(allModels) <- NULL
# list of batches
tmp <- allModels[seq(1, nrow(allModels), 4),]
rownames(tmp) <- NULL
# constants for all models
N <- dat$Population[1]
# used to initialize I0 and R0
lengthI <- 3
# batches by alarmFit (56 batches total)
peak_i <- allModels$peak[i]
alarmBase_i <- allModels$alarmBase[i]
smoothWindow_i <- allModels$smoothWindow[i]
print(paste('Running alarm basis:', alarmBase_i, ', peak:', peak_i))
# what will inform alarm function?
# (shifted so alarm is informed only by data up to time t-1)
dat$alarmBase <- switch(as.character(alarmBase_i),
'inc' = head(movingAverage(c(0, dat$dailyCases),
smoothWindow_i), -1),
'hosp' = head(movingAverage(c(0, dat$dailyHosp),
smoothWindow_i), -1),
'death' = head(movingAverage(c(0, dat$dailyDeaths),
smoothWindow_i), -1))
# get data for the specified peak
incData <- dat$smoothedCases[which(dat$peak == peak_i)]
alarmBase <- dat$alarmBase[which(dat$peak == peak_i)]
# initialize current number of infectious and removed individuals
if (peak_i == 1) {
# peak 1 shift 5 days for start
idxStart <- 5
incData <- incData[-c(1:idxStart)]
alarmBase <- alarmBase[-c(1:idxStart)]
} else {
idxStart <- min(which(dat$peak == peak_i))
incData <- incData[-1]
alarmBase <- alarmBase[-1]
}
# currently infectious
I0 <- sum(dat$smoothedCases[max(1, (idxStart - lengthI + 1)):(idxStart)])
R0 <- dat$cumulativeCases[idxStart] - I0
# used for posterior predictive fit
# previously observed incidence for correct smoothing at beginning of prediction
Istar0 <- dat$smoothedCases[max(1, (idxStart - smoothWindow_i + 1)):(idxStart)]
library(nimble)
# source relevant scripts
source('./scripts/model_fit_uni.R')
samples <- fitAlarmModel(incData = incData, alarmBase = alarmBase,
N = N, I0 = I0, R0 = R0, seed = 1)
head(samples)
plot(samples[,'beta'], type = 'l')
plot(samples[,'w0'], type = 'l')
smoothWindow_i
alarmBase
setwd("C:/Users/caitl/Documents/Postdoc/multipleDataBCM")
i <- 7
### load libraries
library(parallel)
library(nimble)
### source scripts (for movingAverage function)
source('./scripts/modelCodes.R')
### read data
dat <- read.csv('./data/nycClean.csv')
dat$smoothedCases <- round(dat$dailyCases)
dat$cumulativeCases <- cumsum(dat$smoothedCases)
peak <- c('1', '2', '3', '4', '5')
alarmBase <- c('inc', 'hosp', 'death')
smoothWindow <- 60
# 15
allModels <- expand.grid(peak = peak,
alarmBase = alarmBase,
smoothWindow = smoothWindow)
allModels <- allModels[order(allModels$alarmBase,
allModels$smoothWindow,
allModels$peak),]
rownames(allModels) <- NULL
# list of batches
tmp <- allModels[seq(1, nrow(allModels), 4),]
rownames(tmp) <- NULL
# constants for all models
N <- dat$Population[1]
# used to initialize I0 and R0
lengthI <- 3
peak_i <- allModels$peak[i]
alarmBase_i <- allModels$alarmBase[i]
smoothWindow_i <- allModels$smoothWindow[i]
print(paste('Running alarm basis:', alarmBase_i, ', peak:', peak_i))
# what will inform alarm function?
# (shifted so alarm is informed only by data up to time t-1)
dat$alarmBase <- switch(as.character(alarmBase_i),
'inc' = head(movingAverage(c(0, dat$dailyCases),
smoothWindow_i), -1),
'hosp' = head(movingAverage(c(0, dat$dailyHosp),
smoothWindow_i), -1),
'death' = head(movingAverage(c(0, dat$dailyDeaths),
smoothWindow_i), -1))
# get data for the specified peak
incData <- dat$smoothedCases[which(dat$peak == peak_i)]
alarmBase <- dat$alarmBase[which(dat$peak == peak_i)]
# initialize current number of infectious and removed individuals
if (peak_i == 1) {
# peak 1 shift 5 days for start
idxStart <- 5
incData <- incData[-c(1:idxStart)]
alarmBase <- alarmBase[-c(1:idxStart)]
} else {
idxStart <- min(which(dat$peak == peak_i))
incData <- incData[-1]
alarmBase <- alarmBase[-1]
}
# currently infectious
I0 <- sum(dat$smoothedCases[max(1, (idxStart - lengthI + 1)):(idxStart)])
R0 <- dat$cumulativeCases[idxStart] - I0
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData', 'alarmBase', 'N', 'I0', 'R0'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/model_fit_uni.R')
# debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase,
N = N, I0 = I0, R0 = R0, seed = x)
})
stopCluster(cl)
source('./scripts/summarize_post_uni.R')
# debugonce(summarizePost)
# debugonce(postPredFit)
postSummaries <- summarizePost(resThree = resThree, incData = incData,
alarmBase = alarmBase, N = N, I0 = I0, R0 = R0)
postSummaries$diag
postSummaries$gdiag
postSummaries$postParams
postSummaries$postR0
resThree[[1]][,'k']
resThree[[2]][,'k']
resThree[[3]][,'k']
paste0('./output/chains_', alarmBase_i, '_peak',
peak_i, '_', smoothWindow_i, '.rds')
# save results in separate files
modelInfo <- data.frame(alarmBase = alarmBase_i,
peak = peak_i,
smoothWindow = smoothWindow_i)
modelInfo
gr <- cbind.data.frame(postSummaries$gdiag, modelInfo)
paramsPost <- cbind.data.frame(postSummaries$postParams, modelInfo)
alarmPost <- cbind.data.frame(postSummaries$postAlarm, modelInfo)
R0Post <- cbind.data.frame(postSummaries$postR0, modelInfo)
waicPost <- cbind.data.frame(postSummaries$waic, modelInfo)
waicPost
i <- 1
i <- 14
peak_i <- allModels$peak[i]
alarmBase_i <- allModels$alarmBase[i]
smoothWindow_i <- allModels$smoothWindow[i]
print(paste('Running alarm basis:', alarmBase_i, ', peak:', peak_i))
# what will inform alarm function?
# (shifted so alarm is informed only by data up to time t-1)
dat$alarmBase <- switch(as.character(alarmBase_i),
'inc' = head(movingAverage(c(0, dat$dailyCases),
smoothWindow_i), -1),
'hosp' = head(movingAverage(c(0, dat$dailyHosp),
smoothWindow_i), -1),
'death' = head(movingAverage(c(0, dat$dailyDeaths),
smoothWindow_i), -1))
# get data for the specified peak
incData <- dat$smoothedCases[which(dat$peak == peak_i)]
alarmBase <- dat$alarmBase[which(dat$peak == peak_i)]
# initialize current number of infectious and removed individuals
if (peak_i == 1) {
# peak 1 shift 5 days for start
idxStart <- 5
incData <- incData[-c(1:idxStart)]
alarmBase <- alarmBase[-c(1:idxStart)]
} else {
idxStart <- min(which(dat$peak == peak_i))
incData <- incData[-1]
alarmBase <- alarmBase[-1]
}
# currently infectious
I0 <- sum(dat$smoothedCases[max(1, (idxStart - lengthI + 1)):(idxStart)])
R0 <- dat$cumulativeCases[idxStart] - I0
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData', 'alarmBase', 'N', 'I0', 'R0'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/model_fit_uni.R')
# debugonce(fitAlarmModel)
fitAlarmModel(incData = incData, alarmBase = alarmBase,
N = N, I0 = I0, R0 = R0, seed = x)
})
stopCluster(cl)
source('./scripts/summarize_post_uni.R')
# debugonce(summarizePost)
# debugonce(postPredFit)
postSummaries <- summarizePost(resThree = resThree, incData = incData,
alarmBase = alarmBase, N = N, I0 = I0, R0 = R0)
cbind.data.frame(postSummaries$gdiag, modelInfo)
cbind.data.frame(postSummaries$postParams, modelInfo)
cbind.data.frame(postSummaries$postAlarm, modelInfo)
i
# save results in separate files
modelInfo <- data.frame(alarmBase = alarmBase_i,
peak = peak_i,
smoothWindow = smoothWindow_i)
cbind.data.frame(postSummaries$postAlarm, modelInfo)
cbind.data.frame(postSummaries$postR0, modelInfo)
cbind.data.frame(postSummaries$waic, modelInfo)
setwd("C:/Users/caitl/Documents/Postdoc/multipleDataBCM/data")
library(lubridate)
### Read in data from GitHub
nycCases <-read.csv("https://raw.githubusercontent.com/nychealth/coronavirus-data/master/trends/cases-by-day.csv")
nycHosp <-read.csv("https://raw.githubusercontent.com/nychealth/coronavirus-data/master/trends/hosp-by-day.csv")
nycDeath <-read.csv("https://raw.githubusercontent.com/nychealth/coronavirus-data/master/trends/deaths-by-day.csv")
nycCases <- nycCases[,c('date_of_interest', 'CASE_COUNT')]
colnames(nycCases) <- c('date', 'dailyCases')
nycHosp <- nycHosp[,c('date_of_interest', 'HOSPITALIZED_COUNT')]
colnames(nycHosp) <- c('date', 'dailyHosp')
nycDeath <- nycDeath[,c('date_of_interest', 'DEATH_COUNT')]
colnames(nycDeath) <- c('date', 'dailyDeaths')
nyc <- merge(nycCases, nycHosp, by = 'date')
nyc <- merge(nyc, nycDeath, by = 'date')
# format dates
nyc$date <- as.Date(nyc$date, format = '%m/%d/%Y')
nyc <- nyc[order(nyc$date),]
# population
nyc$Population <- 8804190
plot(nyc$date, nyc$dailyCases)
plot(nyc$date, nyc$dailyCases, type = 'l')
plot(nyc$date[which(nyc$date > as.Date('2022-01-01'))], nyc$dailyCases[which(nyc$date > as.Date('2022-01-01'))], type = 'l')
plot(nyc$date[which(nyc$date > as.Date('2022-02-01'))], nyc$dailyCases[which(nyc$date > as.Date('2022-02-01'))], type = 'l')
# peak 5 - Nov 11, 2021 - Mar 1, 2022
startDate <- as.Date('2022-03-01')
endDate <- as.Date('2022-09-16')
nyc$peak[nyc$date >= startDate & nyc$date < endDate]<- 5
plot(nyc$date[which(nyc$peak == 5)], nyc$dailyCases[which(nyc$peak == 5)])
plot(nyc$date[which(nyc$peak == 5)], nyc$dailyCases[which(nyc$peak == 5)], type = 'l')
# smooth data
movingAverage <- function(x, bw) {
n <- length(x)
bw <- floor(bw)
out <- rep(0, n)
for (i in 1:n) {
if (i < bw) {
t1 = 1
t2 = i
} else {
t1 = i - bw + 1
t2 = i
}
out[i] <- mean(x[t1:t2])
}
return(out)
}
nyc$dailyCases <- movingAverage(nyc$dailyCases, 7)
nyc$dailyDeaths <- movingAverage(nyc$dailyDeaths, 7)
nyc$dailyHosp <- movingAverage(nyc$dailyHosp, 7)
plot(nyc$date[which(nyc$peak == 5)], nyc$dailyCases[which(nyc$peak == 5)], type = 'l')
setwd("C:/Users/caitl/Documents/Postdoc/multipleDataBCM/data")
################################################################################
# NYC data formatting
################################################################################
library(lubridate)
### Read in data from GitHub
nycCases <-read.csv("https://raw.githubusercontent.com/nychealth/coronavirus-data/master/trends/cases-by-day.csv")
nycHosp <-read.csv("https://raw.githubusercontent.com/nychealth/coronavirus-data/master/trends/hosp-by-day.csv")
nycDeath <-read.csv("https://raw.githubusercontent.com/nychealth/coronavirus-data/master/trends/deaths-by-day.csv")
nycCases <- nycCases[,c('date_of_interest', 'CASE_COUNT')]
colnames(nycCases) <- c('date', 'dailyCases')
nycHosp <- nycHosp[,c('date_of_interest', 'HOSPITALIZED_COUNT')]
colnames(nycHosp) <- c('date', 'dailyHosp')
nycDeath <- nycDeath[,c('date_of_interest', 'DEATH_COUNT')]
colnames(nycDeath) <- c('date', 'dailyDeaths')
nyc <- merge(nycCases, nycHosp, by = 'date')
nyc <- merge(nyc, nycDeath, by = 'date')
# format dates
nyc$date <- as.Date(nyc$date, format = '%m/%d/%Y')
nyc <- nyc[order(nyc$date),]
# population
nyc$Population <- 8804190
# peak identifier
nyc$peak <- NA
# peak 1 - Feb 29 - Jun 1, 2020
startDate <- as.Date('2020-02-29')
endDate <- as.Date('2020-06-16')
nyc$peak[nyc$date >= startDate & nyc$date < endDate]<- 1
# peak 2 - Oct 01, 2020 - Jun 1, 2021
startDate <- as.Date('2020-10-01')
endDate <- as.Date('2021-05-16')
nyc$peak[nyc$date >= startDate & nyc$date < endDate]<- 2
# peak 3 - Jul 1 - Nov 1, 2021
startDate <- as.Date('2021-07-01')
endDate <- as.Date('2021-11-01')
nyc$peak[nyc$date >= startDate & nyc$date < endDate]<- 3
# peak 4 - Dec 1, 2021 - Feb 15, 2022
startDate <- as.Date('2021-12-01')
endDate <- as.Date('2022-02-16')
nyc$peak[nyc$date >= startDate & nyc$date < endDate]<- 4
# peak 5 - Nov 11, 2021 - Mar 1, 2022
startDate <- as.Date('2022-03-01')
endDate <- as.Date('2022-09-01')
nyc$peak[nyc$date >= startDate & nyc$date < endDate]<- 5
# smooth data
movingAverage <- function(x, bw) {
n <- length(x)
bw <- floor(bw)
out <- rep(0, n)
for (i in 1:n) {
if (i < bw) {
t1 = 1
t2 = i
} else {
t1 = i - bw + 1
t2 = i
}
out[i] <- mean(x[t1:t2])
}
return(out)
}
nyc$dailyCases <- movingAverage(nyc$dailyCases, 7)
nyc$dailyDeaths <- movingAverage(nyc$dailyDeaths, 7)
nyc$dailyHosp <- movingAverage(nyc$dailyHosp, 7)
write.csv(nyc, 'nycClean.csv', quote = F, row.names = F)
# plot(nyc$date[which(nyc$peak == 5)], nyc$dailyCases[which(nyc$peak == 5)], type = 'l')
plot(nyc$date[which(nyc$peak == 5)], nyc$dailyCases[which(nyc$peak == 5)], type = 'l')
